# TOAST config
# Generated with version 3.0.0a21

[operators]
[operators.load_hdf5]
    class = "toast.ops.load_hdf5.LoadHDF5"
    API = 0 # Internal interface version for this operator
    detdata = "[]" # Only load this list of detdata objects
    enabled = false # If True, this class instance is marked as enabled
    files = "[]" # Override `volume` and load a list of files
    force_serial = false # Use serial HDF5 operations, even if parallel support available
    intervals = "[]" # Only load this list of intervals objects
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    meta = "[]" # Only load this list of meta objects
    name = "load_hdf5" # The 'name' of this class instance
    pattern = "obs_.*_.*\\.h5" # Regexp pattern to match files against
    process_rows = "None" # The size of the rectangular process grid in the detector direction.
    shared = "[]" # Only load this list of shared objects
    sort_by_size = false # If True, sort observations by size before load balancing
    volume = "None" # Top-level directory containing the data volume

[operators.load_books]
    class = "sotodlib.toast.ops.load_books.LoadBooks"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for boresight Azimuth
    bands = "[]" # Only load detectors from these bands
    books = "[]" # List of observation book directories
    boresight_angle = "boresight_angle" # Observation shared key for boresight rotation angle (if it is used)
    boresight_azel = "boresight_azel" # Observation shared key for boresight Az/El quaternions
    boresight_radec = "boresight_radec" # Observation shared key for boresight RA/DEC quaternions
    corotator_angle = "corotator_angle" # Observation shared key for corotator_angle (if it is used)
    det_data = "signal" # Observation detdata key for detector signal
    det_flags = "flags" # Observation detdata key for detector flags
    detset_key = "None" # If specified, use this column of the focalplane detector_data to group detectors
    elevation = "elevation" # Observation shared key for boresight Elevation
    enabled = false # If True, this class instance is marked as enabled
    focalplane_dir = "None" # Directory for focalplane models
    frame_intervals = "None" # Observation interval key for frame boundaries
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "load_books" # The 'name' of this class instance
    noise_dir = "None" # Directory for noise models
    shared_flags = "flags" # Observation shared key for common flags
    times = "times" # Observation shared key for timestamps
    wafers = "[]" # Only load detectors from these wafers / stream_ids

[operators.load_context]
    class = "sotodlib.toast.ops.load_context.LoadContext"
    API = 0 # Internal interface version for this operator
    ax_boresight_az = "boresight_az" # Field with boresight Az
    ax_boresight_el = "boresight_el" # Field with boresight El
    ax_boresight_roll = "boresight_roll" # Field with boresight Roll
    ax_det_flags = "[]" # Tuples of (field, bit_value) merged to det_flags
    ax_det_signal = "signal" # Name of field to associate with det_data
    ax_flags = "[]" # Tuples of (field, bit value) merged to shared_flags
    ax_times = "timestamps" # Name of field to associate with times
    axis_detector = "dets" # Name of the LabelAxis for the detector direction
    axis_sample = "samps" # Name of the OffsetAxis for the sample direction
    azimuth = "azimuth" # Observation shared key for boresight Azimuth
    bands = "[]" # Only load this list of band values
    boresight_angle = "None" # Observation shared key for boresight rotation angle (if it is used)
    boresight_azel = "boresight_azel" # Observation shared key for boresight Az/El quaternions
    boresight_radec = "boresight_radec" # Observation shared key for boresight RA/DEC quaternions
    context = "None" # The Context, which should exist on all processes
    context_file = "None" # Create a context from this file
    corotator_angle = "None" # Observation shared key for corotator_angle (if it is used)
    det_data = "signal" # Observation detdata key for detector signal
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flags = "flags" # Observation detdata key for detector flags
    detset_key = "None" # Column of the focalplane detector_data to use for data distribution
    detsets = "[]" # Only load this list of detset values
    elevation = "elevation" # Observation shared key for boresight Elevation
    enabled = false # If True, this class instance is marked as enabled
    hwp_angle = "None" # Observation shared key for HWP angle (if it is used)
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "load_context" # The 'name' of this class instance
    observation_regex = "None" # Regular expression match to apply to observation IDs
    observations = "[]" # List of observation IDs to load
    readout_ids = "[]" # Only load this list of readout_id values
    roll = "roll" # Observation shared key for boresight Roll
    shared_flags = "flags" # Observation shared key for common flags
    telescope_name = "UNKNOWN" # Name of the telescope
    times = "times" # Observation shared key for timestamps

[operators.act_sign]
    class = "sotodlib.toast.ops.act_sign.ActSign"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for the timestream data
    enabled = false # If True, this class instance is marked as enabled
    fp_column = "det_info_optical_sign" # Focalplane table column with sign factor
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "act_sign" # The 'name' of this class instance

[operators.sim_ground]
    class = "toast.ops.sim_ground.SimGround"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for Azimuth
    boresight_azel = "boresight_azel" # Observation shared key for boresight AZ/EL
    boresight_radec = "boresight_radec" # Observation shared key for boresight RA/DEC
    det_data = "signal" # Observation detdata key to initialize
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flags = "flags" # Observation detdata key for flags to initialize
    detset_key = "pixel" # If specified, use this column of the focalplane detector_data to group detectors
    distribute_time = false # Distribute observation data along the time axis rather than detector axis
    el_mod_amplitude = "Quantity('1.00000000000000e+00 deg')" # Range of elevation modulation
    el_mod_rate = "Quantity('0.00000000000000e+00 Hz')" # Modulate elevation continuously at this rate
    el_mod_sine = false # Modulate elevation with a sine wave instead of a triangle wave
    el_mod_step = "Quantity('0.00000000000000e+00 deg')" # Amount to step elevation after each left-right scan pair
    elevation = "elevation" # Observation shared key for Elevation
    elnod_end = false # Perform an el-nod after the scan
    elnod_every_scan = false # Perform el nods every scan
    elnod_interval = "elnod" # Interval name for elnods
    elnod_mask = 4 # Bit mask to raise elevation nod flags with
    elnod_start = false # Perform an el-nod before the scan
    elnods = "[]" # List of relative el_nods
    enabled = true # If True, this class instance is marked as enabled
    fix_rate_on_sky = true # If True, `scan_rate_az` is given in sky coordinates and azimuthal rate on mount will be adjusted to meet it.  If False, `scan_rate_az` is used as the mount azimuthal rate.
    hwp_angle = "None" # Observation shared key for HWP angle
    hwp_rpm = "None" # The rate (in RPM) of the HWP rotation
    hwp_step = "None" # For stepped HWP, the angle of each step
    hwp_step_time = "None" # For stepped HWP, the time between steps
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    leftright_mask = 8 # Bit mask to raise left-to-right flags with
    max_pwv = "None" # Maximum PWV for the simulated weather.
    median_weather = false # Use median weather parameters instead of sampling from the distributions
    name = "sim_ground" # The 'name' of this class instance
    position = "position" # Observation shared key for position
    randomize_phase = false # If True, the Constant Elevation Scan will begin at a randomized phase.
    realization = 0 # The realization index
    rightleft_mask = 16 # Bit mask to raise right-to-left flags with
    scan_accel_az = "Quantity('1.00000000000000e+00 deg / s2')" # Mount scanning rate acceleration for turnarounds
    scan_accel_el = "Quantity('1.00000000000000e+00 deg / s2')" # Mount elevation rate acceleration.
    scan_cosecant_modulation = false # Modulate the scan rate according to 1/sin(az) for uniform depth
    scan_leftright_interval = "scan_leftright" # Interval name for left to right scans
    scan_rate_az = "Quantity('1.00000000000000e+00 deg / s')" # The sky or mount azimuth scanning rate.  See `fix_rate_on_sky`
    scan_rate_el = "Quantity('1.00000000000000e+00 deg / s')" # The sky elevation scanning rate
    scan_rightleft_interval = "scan_rightleft" # Interval name for right to left scans
    scanning_interval = "scanning" # Interval name for scanning
    schedule = "None" # Instance of a GroundSchedule
    session_split_key = "wafer_slot" # Focalplane key for splitting into observations
    shared_flags = "flags" # Observation shared key for common flags
    sun_angle_min = "Quantity('9.00000000000000e+01 deg')" # Minimum angular distance for the scan and the Sun
    sun_close_distance = "Quantity('4.50000000000000e+01 deg')" # 'Sun close' flagging distance
    sun_close_interval = "sun_close" # Interval name for times when the sun is close
    sun_close_mask = 64 # Bit mask to raise Sun close flags with
    sun_up_interval = "sun_up" # Interval name for times when the sun is up
    sun_up_mask = 32 # Bit mask to raise Sun up flags with
    telescope = "None" # This must be an instance of a Telescope
    throw_interval = "throw" # Interval name for scan + turnaround intervals
    throw_leftright_interval = "throw_leftright" # Interval name for left to right scans + turnarounds
    throw_rightleft_interval = "throw_rightleft" # Interval name for right to left scans + turnarounds
    times = "times" # Observation shared key for timestamps
    track_azimuth = false # If True, the azimuth throw is continually adjusted to center the field.
    turn_leftright_interval = "turn_leftright" # Interval name for turnarounds after left to right scans
    turn_rightleft_interval = "turn_rightleft" # Interval name for turnarounds after right to left scans
    turnaround_interval = "turnaround" # Interval name for turnarounds
    turnaround_mask = 2 # Bit mask to raise turnaround flags with
    use_ephem = true # Use PyEphem to convert between horizontal and equatorial systems
    use_qpoint = false # Use qpoint to convert between horizontal and equatorial systems
    velocity = "velocity" # Observation shared key for velocity
    weather = "atacama" # Name of built-in weather site (e.g. 'atacama', 'south_pole') or path to HDF5 file

[operators.corotate_lat]
    class = "sotodlib.toast.ops.corotator.CoRotator"
    API = 0 # Internal interface version for this operator
    boresight_azel = "boresight_azel" # Observation shared key for boresight Az/El
    boresight_radec = "boresight_radec" # Observation shared key for boresight RA/Dec
    corotate_lat = true # If True, rotate LAT receiver to maintain projected focalplane orientation
    corotator_angle = "corotator_angle" # Observation shared key for corotation angle
    elevation = "elevation" # Observation shared key for boresight elevation
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "corotate_lat" # The 'name' of this class instance

[operators.perturb_hwp]
    class = "toast.ops.sim_hwp.PerturbHWP"
    API = 0 # Internal interface version for this operator
    drift_sigma = "None" # 1-sigma relative change in spin rate, such as 0.01 / hour
    enabled = false # If True, this class instance is marked as enabled
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "perturb_hwp" # The 'name' of this class instance
    realization = 0 # Realization index
    time_sigma = "None" # 1-sigma difference between real and nominal time stamps
    times = "times" # Observation shared key for timestamps

[operators.det_pointing_azel]
    class = "toast.ops.pointing_detector.pointing_detector.PointingDetectorSimple"
    API = 0 # Internal interface version for this operator
    boresight = "boresight_radec" # Observation shared key for boresight
    coord_in = "None" # The input boresight coordinate system ('C', 'E', 'G')
    coord_out = "None" # The output coordinate system ('C', 'E', 'G')
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "det_pointing_azel" # The 'name' of this class instance
    quats = "quats_azel" # Observation detdata key for output quaternions
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.det_pointing_radec]
    class = "toast.ops.pointing_detector.pointing_detector.PointingDetectorSimple"
    API = 0 # Internal interface version for this operator
    boresight = "boresight_radec" # Observation shared key for boresight
    coord_in = "None" # The input boresight coordinate system ('C', 'E', 'G')
    coord_out = "None" # The output coordinate system ('C', 'E', 'G')
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "det_pointing_radec" # The 'name' of this class instance
    quats = "quats_radec" # Observation detdata key for output quaternions
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.weights_azel]
    class = "toast.ops.stokes_weights.stokes_weights.StokesWeights"
    API = 0 # Internal interface version for this operator
    IAU = false # If True, use the IAU convention rather than COSMO
    cal = "None" # The observation key with a dictionary of pointing weight calibration for each det
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = true # If True, this class instance is marked as enabled
    fp_gamma = "gamma" # Focalplane key for detector gamma offset angle
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mode = "IQU" # The Stokes weights to generate (I or IQU)
    name = "weights_azel" # The 'name' of this class instance
    single_precision = false # If True, use 32bit float in output
    view = "None" # Use this view of the data in all observations
    weights = "weights_azel" # Observation detdata key for output weights

[operators.weights_radec]
    class = "toast.ops.stokes_weights.stokes_weights.StokesWeights"
    API = 0 # Internal interface version for this operator
    IAU = false # If True, use the IAU convention rather than COSMO
    cal = "None" # The observation key with a dictionary of pointing weight calibration for each det
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = true # If True, this class instance is marked as enabled
    fp_gamma = "gamma" # Focalplane key for detector gamma offset angle
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mode = "IQU" # The Stokes weights to generate (I or IQU)
    name = "weights_radec" # The 'name' of this class instance
    single_precision = false # If True, use 32bit float in output
    view = "None" # Use this view of the data in all observations
    weights = "weights" # Observation detdata key for output weights

[operators.pixels_healpix_radec]
    class = "toast.ops.pixels_healpix.pixels_healpix.PixelsHealpix"
    API = 0 # Internal interface version for this operator
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_healpix_radec" # The 'name' of this class instance
    nest = true # If True, use NESTED ordering instead of RING
    nside = 64 # The NSIDE resolution
    nside_submap = 16 # The NSIDE of the submap resolution
    pixels = "pixels" # Observation detdata key for output pixel indices
    single_precision = false # If True, use 32bit int in output
    view = "None" # Use this view of the data in all observations

[operators.pixels_healpix_radec_final]
    class = "toast.ops.pixels_healpix.pixels_healpix.PixelsHealpix"
    API = 0 # Internal interface version for this operator
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_healpix_radec_final" # The 'name' of this class instance
    nest = true # If True, use NESTED ordering instead of RING
    nside = 64 # The NSIDE resolution
    nside_submap = 16 # The NSIDE of the submap resolution
    pixels = "pixels" # Observation detdata key for output pixel indices
    single_precision = false # If True, use 32bit int in output
    view = "None" # Use this view of the data in all observations

[operators.pixels_wcs_azel]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = true # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "(Quantity('1.80000000000000e+02 deg'),Quantity('0.00000000000000e+00 deg'),)" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(710,350,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_wcs_azel" # The 'name' of this class instance
    pixels = "pixels" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN
    resolution = "(Quantity('5.00000000000000e-03 deg'),Quantity('5.00000000000000e-03 deg'),)" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 1 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.pixels_wcs_azel_final]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = false # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "(Quantity('1.80000000000000e+02 deg'),Quantity('0.00000000000000e+00 deg'),)" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(710,350,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_wcs_azel_final" # The 'name' of this class instance
    pixels = "pixels" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN
    resolution = "(Quantity('5.00000000000000e-01 deg'),Quantity('5.00000000000000e-01 deg'),)" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 10 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.pixels_wcs_radec]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = true # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "(Quantity('1.80000000000000e+02 deg'),Quantity('0.00000000000000e+00 deg'),)" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(710,350,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_wcs_radec" # The 'name' of this class instance
    pixels = "pixels" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN
    resolution = "(Quantity('5.00000000000000e-03 deg'),Quantity('5.00000000000000e-03 deg'),)" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 1 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.pixels_wcs_radec_final]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = false # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "(Quantity('1.80000000000000e+02 deg'),Quantity('0.00000000000000e+00 deg'),)" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(710,350,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "pixels_wcs_radec_final" # The 'name' of this class instance
    pixels = "pixels" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN
    resolution = "(Quantity('5.00000000000000e-01 deg'),Quantity('5.00000000000000e-01 deg'),)" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 10 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.az_intervals]
    class = "toast.ops.azimuth_intervals.AzimuthIntervals"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for Azimuth
    debug_root = "None" # If not None, dump debug plots to this root file name
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "az_intervals" # The 'name' of this class instance
    scan_leftright_interval = "scan_leftright" # Interval name for left to right scans
    scan_rightleft_interval = "scan_rightleft" # Interval name for right to left scans
    scanning_interval = "scanning" # Interval name for scanning
    shared_flag_mask = 1 # Bit mask value for bad azimuth pointing
    shared_flags = "flags" # Observation shared key for telescope flags to use
    throw_interval = "throw" # Interval name for scan + turnaround intervals
    throw_leftright_interval = "throw_leftright" # Interval name for left to right scans + turnarounds
    throw_rightleft_interval = "throw_rightleft" # Interval name for right to left scans + turnarounds
    times = "times" # Observation shared key for timestamps
    turn_leftright_interval = "turn_leftright" # Interval name for turnarounds after left to right scans
    turn_rightleft_interval = "turn_rightleft" # Interval name for turnarounds after right to left scans
    turnaround_interval = "turnaround" # Interval name for turnarounds
    window_seconds = 0.25 # Smoothing window in seconds

[operators.default_model]
    class = "toast.ops.noise_model.DefaultNoiseModel"
    API = 0 # Internal interface version for this operator
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "default_model" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key for storing the noise model

[operators.elevation_model]
    class = "toast.ops.elevation_noise.ElevationNoise"
    API = 0 # Internal interface version for this operator
    detector_pointing = "None" # Operator that translates boresight Az / El pointing into detector frame
    enabled = true # If True, this class instance is marked as enabled
    extra_factor = "None" # Extra multiplier to the NET scaling
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    modulate_pwv = false # If True, modulate the NET based on PWV
    name = "elevation_model" # The 'name' of this class instance
    noise_a = "None" # Parameter 'a' in (a / sin(el) + c).  If not set, look for one in the Focalplane.
    noise_c = "None" # Parameter 'c' in (a / sin(el) + c).  If not set, look for one in the Focalplane.
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "noise_model" # Create a new noise model with this name
    pwv_a0 = "None" # Parameter 'a0' in (a0 + pwv * a1 + pwv ** 2 * a2).  If not set, look for one in the Focalplane.
    pwv_a1 = "None" # Parameter 'a1' in (a0 + pwv * a1 + pwv ** 2 * a2).  If not set, look for one in the Focalplane.
    pwv_a2 = "None" # Parameter 'a2' in (a0 + pwv * a1 + pwv ** 2 * a2).  If not set, look for one in the Focalplane.
    times = "times" # Observation shared key for timestamps
    view = "None" # Use this view of the data in all observations.  Use 'middle' if the middle 10 seconds of each observation is enough to determine the effective observing elevation

[operators.common_mode_noise]
    class = "toast.ops.common_mode_noise.CommonModeNoise"
    API = 0 # Internal interface version for this operator
    NET = "None" # 
    alpha = "None" # 
    component = 0 # The noise component index
    coupling_strength_center = 1.0 # Mean coupling strength between the detectors and the common mode
    coupling_strength_width = 0.0 # Width of the coupling strength distribution about `coupling_strength_center`
    detset = "[]" # List of detectors to add the common mode to.  Only used if `focalplane_key` is None
    enabled = false # If True, this class instance is marked as enabled
    fknee = "None" # 
    fmin = "None" # 
    focalplane_key = "None" # Detectors sharing the focalplane key will have the same common mode
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "common_mode_noise" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "None" # Create a new noise model with this name
    realization = 0 # The noise component index
    static_coupling = false # If True, coupling to the common mode is not randomized over observations and realizations

[operators.sim_atmosphere_coarse]
    class = "toast.ops.sim_tod_atm.SimAtmosphere"
    API = 0 # Internal interface version for this operator
    add_loading = false # Add elevation-dependent loading.
    cache_dir = "None" # Directory to use for loading / saving atmosphere realizations
    cache_only = false # If True, only cache the atmosphere, do not observe it.
    component = 123456 # The component index to use for this atmosphere simulation
    debug_plots = false # If True, make plots of the debug snapshots
    debug_snapshots = false # If True, dump snapshots of the atmosphere slabs to pickle files
    debug_spectrum = false # If True, dump out Kolmogorov debug files
    debug_tod = false # If True, dump TOD to pickle files
    det_data = "signal" # Observation detdata key for accumulating atmosphere timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    detector_weights = "None" # Operator that translates boresight Az/El pointing into detector weights
    enabled = false # If True, this class instance is marked as enabled
    fade_time = "Quantity('6.00000000000000e+01 s')" # Fade in/out time to avoid a step at wind break.
    field_of_view = "None" # Override the focalplane field of view
    gain = 0.0006 # Scaling applied to the simulated TOD
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax_center = "Quantity('1.00000000000000e+04 m')" # Kolmogorov turbulence injection scale center
    lmax_sigma = "Quantity('1.00000000000000e+03 m')" # Kolmogorov turbulence injection scale sigma
    lmin_center = "Quantity('3.00000000000000e+02 m')" # Kolmogorov turbulence dissipation scale center
    lmin_sigma = "Quantity('3.00000000000000e+01 m')" # Kolmogorov turbulence dissipation scale sigma
    n_bandpass_freqs = 100 # The number of sampling frequencies used when convolving the bandpass with atmosphere absorption and loading
    name = "sim_atmosphere_coarse" # The 'name' of this class instance
    nelem_sim_max = 30000 # Controls the size of the simulation slices
    overwrite_cache = false # If True, redo and overwrite any cached atmospheric realizations.
    polarization_fraction = 0.0 # Polarization fraction (only Q polarization).
    realization = 1000000 # If simulating multiple realizations, the realization index
    sample_rate = "None" # Rate at which to sample atmospheric TOD before interpolation.  Default is no interpolation.
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps
    turnaround_interval = "turnaround" # Interval name for turnarounds
    view = "None" # Use this view of the data in all observations
    wind_dist = "Quantity('1.00000000000000e+04 m')" # Maximum wind drift before discarding the volume and creating a new one
    xstep = "Quantity('5.00000000000000e+01 m')" # Size of volume elements in X direction
    ystep = "Quantity('5.00000000000000e+01 m')" # Size of volume elements in Y direction
    z0_center = "Quantity('2.00000000000000e+03 m')" # Central value of the water vapor distribution
    z0_sigma = "Quantity('0.00000000000000e+00 m')" # Sigma of the water vapor distribution
    zatm = "Quantity('4.00000000000000e+04 m')" # Atmosphere extent for temperature profile
    zmax = "Quantity('2.00000000000000e+03 m')" # Atmosphere extent for water vapor integration
    zstep = "Quantity('5.00000000000000e+01 m')" # Size of volume elements in Z direction

[operators.sim_atmosphere]
    class = "toast.ops.sim_tod_atm.SimAtmosphere"
    API = 0 # Internal interface version for this operator
    add_loading = true # Add elevation-dependent loading.
    cache_dir = "None" # Directory to use for loading / saving atmosphere realizations
    cache_only = false # If True, only cache the atmosphere, do not observe it.
    component = 123456 # The component index to use for this atmosphere simulation
    debug_plots = false # If True, make plots of the debug snapshots
    debug_snapshots = false # If True, dump snapshots of the atmosphere slabs to pickle files
    debug_spectrum = false # If True, dump out Kolmogorov debug files
    debug_tod = false # If True, dump TOD to pickle files
    det_data = "signal" # Observation detdata key for accumulating atmosphere timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    detector_weights = "None" # Operator that translates boresight Az/El pointing into detector weights
    enabled = false # If True, this class instance is marked as enabled
    fade_time = "Quantity('6.00000000000000e+01 s')" # Fade in/out time to avoid a step at wind break.
    field_of_view = "None" # Override the focalplane field of view
    gain = 4e-05 # Scaling applied to the simulated TOD
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax_center = "Quantity('1.00000000000000e+00 m')" # Kolmogorov turbulence injection scale center
    lmax_sigma = "Quantity('1.00000000000000e-01 m')" # Kolmogorov turbulence injection scale sigma
    lmin_center = "Quantity('1.00000000000000e-03 m')" # Kolmogorov turbulence dissipation scale center
    lmin_sigma = "Quantity('1.00000000000000e-04 m')" # Kolmogorov turbulence dissipation scale sigma
    n_bandpass_freqs = 100 # The number of sampling frequencies used when convolving the bandpass with atmosphere absorption and loading
    name = "sim_atmosphere" # The 'name' of this class instance
    nelem_sim_max = 10000 # Controls the size of the simulation slices
    overwrite_cache = false # If True, redo and overwrite any cached atmospheric realizations.
    polarization_fraction = 0.0 # Polarization fraction (only Q polarization).
    realization = 0 # If simulating multiple realizations, the realization index
    sample_rate = "None" # Rate at which to sample atmospheric TOD before interpolation.  Default is no interpolation.
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps
    turnaround_interval = "turnaround" # Interval name for turnarounds
    view = "None" # Use this view of the data in all observations
    wind_dist = "Quantity('1.00000000000000e+03 m')" # Maximum wind drift before discarding the volume and creating a new one
    xstep = "Quantity('4.00000000000000e+00 m')" # Size of volume elements in X direction
    ystep = "Quantity('4.00000000000000e+00 m')" # Size of volume elements in Y direction
    z0_center = "Quantity('2.00000000000000e+03 m')" # Central value of the water vapor distribution
    z0_sigma = "Quantity('0.00000000000000e+00 m')" # Sigma of the water vapor distribution
    zatm = "Quantity('4.00000000000000e+04 m')" # Atmosphere extent for temperature profile
    zmax = "Quantity('2.00000000000000e+02 m')" # Atmosphere extent for water vapor integration
    zstep = "Quantity('4.00000000000000e+00 m')" # Size of volume elements in Z direction

[operators.scan_map]
    class = "toast.ops.scan_healpix.ScanHealpixMap"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for accumulating output.  Use ';' if different files are applied to different flavors
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    file = "None" # Path to healpix FITS file.  Use ';' if providing multiple files
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "scan_map" # The 'name' of this class instance
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    save_map = false # If True, do not delete map during finalize
    save_pointing = false # If True, do not clear detector pointing matrices if we generate the pixel distribution
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    subtract = false # If True, subtract the map timestream instead of accumulating
    zero = false # If True, zero the data before accumulating / subtracting

[operators.scan_map_weights]
    class = "toast.ops.stokes_weights.stokes_weights.StokesWeights"
    API = 0 # Internal interface version for this operator
    IAU = false # If True, use the IAU convention rather than COSMO
    cal = "None" # The observation key with a dictionary of pointing weight calibration for each det
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    fp_gamma = "gamma" # Focalplane key for detector gamma offset angle
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mode = "IQU" # The Stokes weights to generate (I or IQU)
    name = "scan_map_weights" # The 'name' of this class instance
    single_precision = false # If True, use 32bit float in output
    view = "None" # Use this view of the data in all observations
    weights = "weights_scan_map" # Observation detdata key for output weights

[operators.scan_map_pixels]
    class = "toast.ops.pixels_healpix.pixels_healpix.PixelsHealpix"
    API = 0 # Internal interface version for this operator
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "scan_map_pixels" # The 'name' of this class instance
    nest = true # If True, use NESTED ordering instead of RING
    nside = 64 # The NSIDE resolution
    nside_submap = 16 # The NSIDE of the submap resolution
    pixels = "pixels_scan_map" # Observation detdata key for output pixel indices
    single_precision = false # If True, use 32bit int in output
    view = "None" # Use this view of the data in all observations

[operators.scan_wcs_map]
    class = "toast.ops.scan_wcs.ScanWCSMap"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for accumulating output
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    file = "None" # Path to FITS file
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "scan_wcs_map" # The 'name' of this class instance
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    save_map = false # If True, do not delete map during finalize
    save_pointing = false # If True, do not clear detector pointing matrices if we generate the pixel distribution
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    subtract = false # If True, subtract the map timestream instead of accumulating
    zero = false # If True, zero the data before accumulating / subtracting

[operators.scan_wcs_map_weights]
    class = "toast.ops.stokes_weights.stokes_weights.StokesWeights"
    API = 0 # Internal interface version for this operator
    IAU = false # If True, use the IAU convention rather than COSMO
    cal = "None" # The observation key with a dictionary of pointing weight calibration for each det
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    fp_gamma = "gamma" # Focalplane key for detector gamma offset angle
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mode = "IQU" # The Stokes weights to generate (I or IQU)
    name = "scan_wcs_map_weights" # The 'name' of this class instance
    single_precision = false # If True, use 32bit float in output
    view = "None" # Use this view of the data in all observations
    weights = "weights_scan_map" # Observation detdata key for output weights

[operators.scan_wcs_map_pixels]
    class = "toast.ops.pixels_wcs.PixelsWCS"
    API = 0 # Internal interface version for this operator
    auto_bounds = true # If True, set the bounding box based on boresight and field of view
    bounds = "()" # The (lon_min, lon_max, lat_min, lat_max) values (Quantities)
    center = "(Quantity('1.80000000000000e+02 deg'),Quantity('0.00000000000000e+00 deg'),)" # The center Lon/Lat coordinates (Quantities) of the projection
    center_offset = "None" # Optional name of shared field with lon, lat offset in degrees
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dimensions = "(710,350,)" # The Lon/Lat pixel dimensions of the projection
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "scan_wcs_map_pixels" # The 'name' of this class instance
    pixels = "pixels_scan_map" # Observation detdata key for output pixel indices
    projection = "CAR" # Supported values are CAR, CEA, MER, ZEA, TAN
    resolution = "(Quantity('5.00000000000000e-03 deg'),Quantity('5.00000000000000e-03 deg'),)" # The Lon/Lat projection resolution (Quantities) along the 2 axes
    single_precision = false # If True, use 32bit int in output
    submaps = 1 # Number of submaps to use
    use_astropy = true # If True, use astropy for world to pix conversion
    view = "None" # Use this view of the data in all observations

[operators.conviqt]
    class = "toast.ops.conviqt.SimConviqt"
    API = 0 # Internal interface version for this operator
    apply_flags = false # Only synthesize signal for unflagged samples.
    beam_file = "None" # File containing the beam a_lm expansion.  Tag {detector} will be replaced with the detector name.
    beam_file_dict = "{}" # Dictionary of files containing the beam a_lm expansions. An entry for each detector name must be present. If provided, supersedes `beam_file`.
    beammmax = -1 # Beam maximum m.  Actual resolution in the Healpix FITS file may differ. If not set, will use the maximum expansion order from file.
    calibrate = true # Calibrate intensity to 1.0, rather than (1 + epsilon) / 2. Calibrate has no effect if the beam is found to be normalized rather than scaled with the leakage factor.
    comm = "None" # MPI communicator to use for the convolution. libConviqt does not work without MPI.
    det_data = "signal" # Observation detdata key for accumulating convolved timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dxx = true # The beam frame is either Dxx or Pxx. Pxx includes the rotation to polarization sensitive basis, Dxx does not. When Dxx=True, detector orientation from attitude quaternions is corrected for the polarization angle.
    enabled = false # If True, this class instance is marked as enabled
    fwhm = "Quantity('4.00000000000000e+00 arcmin')" # Width of a symmetric gaussian beam already present in the skyfile (will be deconvolved away).
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax = -1 # Maximum ell (and m).  Actual resolution in the Healpix FITS file may differ.  If not set, will use the maximum expansion order from file.
    mc = "None" # Monte Carlo index used in synthesizing the input file names.
    name = "conviqt" # The 'name' of this class instance
    normalize_beam = false # Normalize beam to have unit response to temperature monopole.
    order = 13 # Conviqt order parameter (expert mode)
    pol = true # Toggle simulated signal polarization
    remove_dipole = false # Suppress the temperature dipole in sky_file.
    remove_monopole = false # Suppress the temperature monopole in sky_file.
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    sky_file = "None" # File containing the sky a_lm expansion.  Tag {detector} will be replaced with the detector name
    sky_file_dict = "{}" # Dictionary of files containing the sky a_lm expansions. An entry for each detector name must be present. If provided, supersedes `sky_file`.
    verbosity = 0 # 
    view = "None" # Use this view of the data in all observations

[operators.conviqt_teb]
    class = "toast.ops.conviqt.SimTEBConviqt"
    API = 0 # Internal interface version for this operator
    apply_flags = false # Only synthesize signal for unflagged samples.
    beam_file = "None" # File containing the beam a_lm expansion.  Tag {detector} will be replaced with the detector name.
    beam_file_dict = "{}" # Dictionary of files containing the beam a_lm expansions. An entry for each detector name must be present. If provided, supersedes `beam_file`.
    beammmax = -1 # Beam maximum m.  Actual resolution in the Healpix FITS file may differ. If not set, will use the maximum expansion order from file.
    calibrate = true # Calibrate intensity to 1.0, rather than (1 + epsilon) / 2. Calibrate has no effect if the beam is found to be normalized rather than scaled with the leakage factor.
    comm = "None" # MPI communicator to use for the convolution. libConviqt does not work without MPI.
    det_data = "signal" # Observation detdata key for accumulating convolved timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    dxx = true # The beam frame is either Dxx or Pxx. Pxx includes the rotation to polarization sensitive basis, Dxx does not. When Dxx=True, detector orientation from attitude quaternions is corrected for the polarization angle.
    enabled = false # If True, this class instance is marked as enabled
    fwhm = "Quantity('4.00000000000000e+00 arcmin')" # Width of a symmetric gaussian beam already present in the skyfile (will be deconvolved away).
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax = -1 # Maximum ell (and m).  Actual resolution in the Healpix FITS file may differ.  If not set, will use the maximum expansion order from file.
    mc = "None" # Monte Carlo index used in synthesizing the input file names.
    name = "conviqt_teb" # The 'name' of this class instance
    normalize_beam = false # Normalize beam to have unit response to temperature monopole.
    order = 13 # Conviqt order parameter (expert mode)
    pol = true # Toggle simulated signal polarization
    remove_dipole = false # Suppress the temperature dipole in sky_file.
    remove_monopole = false # Suppress the temperature monopole in sky_file.
    shared_flag_mask = 1 # Bit mask value for optional flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    sky_file = "None" # File containing the sky a_lm expansion.  Tag {detector} will be replaced with the detector name
    sky_file_dict = "{}" # Dictionary of files containing the sky a_lm expansions. An entry for each detector name must be present. If provided, supersedes `sky_file`.
    verbosity = 0 # 
    view = "None" # Use this view of the data in all observations

[operators.sim_sss]
    class = "toast.ops.sss.SimScanSynchronousSignal"
    API = 0 # Internal interface version for this operator
    component = 663056 # The simulation component index
    det_data = "signal" # Observation detdata key for accumulating simulated timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    fwhm = "Quantity('1.00000000000000e+01 arcmin')" # ground map smoothing scale
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lmax = 256 # ground map expansion order
    name = "sim_sss" # The 'name' of this class instance
    nside = 128 # ground map healpix resolution
    path = "None" # path to a horizontal Healpix map to sample for the SSS *instead* of synthesizing Gaussian maps
    power = -1.0 # exponential for suppressing ground pickup at higher observing elevation
    realization = 0 # The simulation realization index
    scale = "Quantity('1.00000000000000e+00 mK')" # RMS of the ground signal fluctuations at el=45deg

[operators.sim_source]
    class = "sotodlib.toast.ops.sim_source.SimSource"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for azimuth
    beam_file = "None" # HDF5 file that stores the simulated beam
    det_data = "signal" # Observation detdata key for simulated signal
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    detector_weights = "None" # Operator that translates boresight Az/El pointing into detector weights
    drone_emiss = 0.0 # Emissivity of the drone
    drone_size = "Quantity('0.00000000000000e+00 m')" # Drone size in meters
    drone_temp = "Quantity('0.00000000000000e+00 K')" # BlackBody temperature of the Drone
    elevation = "elevation" # Observation shared key for boresight elevation
    enabled = false # If True, this class instance is marked as enabled
    focalplane = "None" # Focalplane instance used for FoV calculation
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_source" # The 'name' of this class instance
    polarization_fraction = 1.0 # Polarization fraction of the emitted signal
    source_amplitude = 0.0 # Amplitude of the source signal with the respect to the background in dB
    source_azimuth_acceleration = "Quantity('2.00000000000000e+00 deg / s2')" # Maximum acceleration of the drone along the azimuthal axis
    source_azimuth_direction = "increasing" # Determine if the azimuth value is increasing or decreasing
    source_azimuth_range = "Quantity('0.00000000000000e+00 deg')" # Range of the scan along the azimuthal axis
    source_azimuth_velocity = "Quantity('2.00000000000000e+00 deg / s')" # Maximum velocity of the drone along the azimuthal axis
    source_distance = "Quantity('5.00000000000000e+02 m')" # Initial distance of the artificial source in meters
    source_elevation_acceleration = "Quantity('2.00000000000000e+00 deg / s2')" # Maximum acceleration of the drone along the elevation axis
    source_elevation_direction = "increasing" # Determine if the elevation value is increasing or decreasing
    source_elevation_range = "Quantity('0.00000000000000e+00 deg')" # Range of the scan along the elevation axis
    source_elevation_step = "Quantity('0.00000000000000e+00 deg')" # Step along the elevation axis for a grid scan
    source_elevation_velocity = "Quantity('2.00000000000000e+00 deg / s')" # Maximum velocity of the drone along the elevation axis
    source_err = "[0,0,0,]" # Source Position Error in ECEF Coordinates as [[X, Y, Z]] in meters
    source_fc = "Quantity('9.00000000000000e+10 Hz')" # Central frequency of the source
    source_freq_chopping = "Quantity('0.00000000000000e+00 Hz')" # Frequency of the source chopping system
    source_gain = 0.0 # Gain of the source Antenna in dBi
    source_noise_bw = "Quantity('0.00000000000000e+00 W / Hz')" # White noise level in the emission band
    source_noise_out = "Quantity('0.00000000000000e+00 W / Hz')" # White noise level outside the emission band
    source_pol_angle = "Quantity('9.00000000000000e+01 deg')" # Angle of the polarization vector emitted by the source in degrees (0 means parallel to the gorund and 90 vertical)
    source_pol_angle_error = "Quantity('0.00000000000000e+00 deg')" # Error in the angle of the polarization vector
    source_power = 0.0 # Max amplitude of the source in dBm
    source_scan_type = "elevation_only" # Type of the scan
    source_size = "Quantity('1.00000000000000e-01 m')" # Source Size in meters
    source_width = "Quantity('1.00000000000000e+05 Hz')" # Width of the source signal
    times = "times" # Observation shared key for timestamps
    wind_damp = 0.0 # Dampening effect to reduce the movement of the drone due to gusts
    wind_gusts_amp = "Quantity('0.00000000000000e+00 m / s')" # Amplitude of gusts of wind
    wind_gusts_duration = "Quantity('0.00000000000000e+00 s')" # Duration of each gust of wind
    wind_gusts_number = 0.0 # Number of wind gusts

[operators.sim_sso]
    class = "sotodlib.toast.ops.sim_sso.SimSSO"
    API = 0 # Internal interface version for this operator
    beam_file = "None" # HDF5 file that stores the simulated beam
    det_data = "signal" # Observation detdata key for simulated signal
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    detector_weights = "None" # Operator that translates boresight Az/El pointing into detector weights
    enabled = false # If True, this class instance is marked as enabled
    finite_sso_radius = false # Treat sources as finite and convolve beam with a disc.
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_sso" # The 'name' of this class instance
    polarization_angle = "Quantity('0.00000000000000e+00 deg')" # Polarization angle for all simulated SSOs. Measured in the same as `detector_weights`
    polarization_fraction = 0.0 # Polarization fraction for all simulated SSOs
    sso_name = "None" # Name of the SSO(s), must be recognized by pyEphem
    times = "times" # Observation shared key for timestamps

[operators.sim_catalog]
    class = "sotodlib.toast.ops.sim_catalog.SimCatalog"
    API = 0 # Internal interface version for this operator
    beam_file = "None" # HDF5 file that stores the simulated beam
    catalog_file = "None" # Name of the TOML catalog file
    det_data = "signal" # Observation detdata key for simulated signal
    det_data_units = "Unit('K')" # Output units if creating detector data
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_catalog" # The 'name' of this class instance
    times = "times" # Observation shared key for timestamps

[operators.sim_wiregrid]
    class = "sotodlib.toast.ops.sim_wiregrid.SimWireGrid"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for simulated signal
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    detector_weights = "None" # Operator that translates boresight Az/El pointing into detector weights
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_wiregrid" # The 'name' of this class instance
    shared_flag_mask_unstable = 255 # Bit mask value applied during wire grid rotation
    shared_flag_mask_wiregrid = 1 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps
    wiregrid_angle = "wiregrid_angle" # Observation shared key for wiregrid angle
    wiregrid_angle_start = "Quantity('0.00000000000000e+00 deg')" # Starting orientation of the wiregrid
    wiregrid_angular_acceleration = "Quantity('1.80000000000000e+02 deg / s2')" # Rotation acceleration
    wiregrid_angular_speed = "Quantity('1.80000000000000e+02 deg / s')" # Rotation speed
    wiregrid_step_length = "Quantity('1.00000000000000e+01 s')" # Time between orientations
    wiregrid_step_size = "Quantity('2.25000000000000e+01 deg')" # Step between orientations

[operators.sim_stimulator]
    class = "sotodlib.toast.ops.sim_stimulator.SimStimulator"
    API = 0 # Internal interface version for this operator
    blackbody_temperature = "Quantity('1.70000000000000e+01 mK')" # Chopper temperature
    chopper_acceleration = "Quantity('3.00000000000000e+02 rad / s2')" # Angular acceleration of the chopper
    chopper_blade_count = 4 # Number of chopper blades
    chopper_blade_width = "Quantity('4.50000000000000e+01 deg')" # Chopper blade_width
    chopper_rates = "7,16,35,65,100,125,150" # Chopper modulation rates as comma-separated values [Hz]
    chopper_state = "chopper_state" # Observation key for chopper state
    chopper_step_time = "Quantity('6.00000000000000e+01 s')" # Single chopper frequency step length
    det_data = "signal" # Observation detdata key for simulated signal
    enabled = false # If True, this class instance is marked as enabled
    heater_aperture_diameter = "Quantity('4.40000000000000e+01 mm')" # Heater aperture at chopper
    heater_aperture_distance = "Quantity('7.05000000000000e+01 mm')" # Heater aperture from chopper axis
    heater_temperature = "Quantity('7.70000000000000e+01 mK')" # Stimulator target temperature
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_stimulator" # The 'name' of this class instance
    shared_flag_mask_stimulator = 1 # Bit mask value for optional shared flagging
    shared_flag_mask_unstable = 255 # Bit mask value applied during stimulator calibration
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stimulator_temperature = "stimulator" # Observation shared key for stimulator temperature
    times = "times" # Observation shared key for timestamps

[operators.convolve_time_constant]
    class = "toast.ops.time_constant.TimeConstant"
    API = 0 # Internal interface version for this operator
    deconvolve = false # Deconvolve the time constant instead.
    det_data = "signal" # Observation detdata key apply filtering to
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "convolve_time_constant" # The 'name' of this class instance
    realization = 0 # Realization ID, only used if tau_sigma is nonzero
    tau = "None" # Time constant to apply to all detectors.  Overrides `tau_name`
    tau_name = "None" # Key to use to find time constants in the Focalplane.
    tau_sigma = "None" # Randomized fractional error to add to each time constant.

[operators.sim_mumux_crosstalk]
    class = "sotodlib.toast.ops.sim_mumux_crosstalk.SimMuMUXCrosstalk"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for simulated signal
    det_flag_mask = 1 # Bit mask value for optional detector flagging
    det_flags = "flags" # Observation detdata key for flags to use
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_mumux_crosstalk" # The 'name' of this class instance
    realization = 0 # Realization ID
    shared_flag_mask = 1 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps

[operators.sim_noise]
    class = "toast.ops.sim_tod_noise.SimNoise"
    API = 0 # Internal interface version for this operator
    component = 0 # The noise component index
    det_data = "signal" # Observation detdata key for accumulating noise timestreams
    det_data_units = "Unit('K')" # Output units if creating detector data
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_noise" # The 'name' of this class instance
    noise_model = "noise_model" # Observation key containing the noise model
    realization = 0 # The noise realization index
    serial = true # Use legacy serial implementation instead of batched
    times = "times" # Observation shared key for timestamps

[operators.sim_hwpss]
    class = "sotodlib.toast.ops.sim_hwpss.SimHWPSS"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key for simulated signal
    enabled = false # If True, this class instance is marked as enabled
    fname_hwpss = "/home/bai-chiang/miniforge3/envs/so_0.0.5.dev186/lib/python3.10/site-packages/sotodlib/toast/ops/data/hwpss_per_chi.pck" # File containing measured or estimated HWPSS profiles
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "sim_hwpss" # The 'name' of this class instance
    stokes_weights = "None" # This must be an instance of a Stokes weights operator

[operators.yield_cut]
    class = "toast.ops.yield_cut.YieldCut"
    API = 0 # Internal interface version for this operator
    det_flag_mask = 1 # Bit mask value for flagging cut detectors
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for input per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    fixed = false # If True, detector cuts do not change between observations and realizations
    focalplane_key = "pixel" # Which focalplane key to use for randomization.  Detectors that share the key value are flagged together
    keep_frac = 0.9 # Fraction of detectors to keep
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "yield_cut" # The 'name' of this class instance
    realization = 0 # The realization index

[operators.gainscrambler]
    class = "toast.ops.gainscrambler.GainScrambler"
    API = 0 # Internal interface version for this operator
    center = 1.0 # Gain distribution center
    component = 0 # Component index for this simulation
    det_data = "signal" # Observation detdata key to apply the gain error to
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "gainscrambler" # The 'name' of this class instance
    pattern = ".*" # Regex pattern to match against detector names. Only detectors that match the pattern are scrambled.
    realization = 0 # Realization index
    sigma = 0.001 # Gain distribution width

[operators.sim_readout]
    class = "sotodlib.toast.ops.sim_readout.SimReadout"
    API = 0 # Internal interface version for this operator
    bias_line_glitch_amplitude_center = "Quantity('1.00000000000000e+00 K')" # Center of Gaussian distribution for glitch amplitude
    bias_line_glitch_amplitude_scatter = 1.0 # Width of Gaussian distribution for *relative* glitch amplitude.  Negative factors get cropped.
    bias_line_glitch_amplitude_sigma = "Quantity('1.00000000000000e+00 K')" # Width of Gaussian distribution for glitch amplitude
    bias_line_glitch_rate = "Quantity('1.00000000000000e-01 Hz')" # Glitch occurrence rate
    bias_line_jump_amplitude_center = "Quantity('0.00000000000000e+00 mK')" # Center of Gaussian distribution for jump amplitude
    bias_line_jump_amplitude_scatter = 1.0 # Width of Gaussian distribution for *relative* jump amplitude.  Negative factors get cropped.
    bias_line_jump_amplitude_sigma = "Quantity('1.00000000000000e+00 mK')" # Width of Gaussian distribution for jump amplitude
    bias_line_jump_rate = "Quantity('1.00000000000000e-03 Hz')" # Jump occurrence rate
    cosmic_ray_correlation_length = "Quantity('1.00000000000000e+01 mm')" # Distance scale of cosmic ray events on the focalplane
    cosmic_ray_glitch_amplitude_center = "Quantity('1.00000000000000e+00 K')" # Center of Gaussian distribution for glitch amplitude
    cosmic_ray_glitch_amplitude_sigma = "Quantity('1.00000000000000e+00 K')" # Width of Gaussian distribution for glitch amplitude
    cosmic_ray_glitch_rate = "Quantity('1.00000000000000e-06 Hz / mm2')" # Cosmic ray glitch rate *either* per unit focalplane area e.g. [Hz / mm^2] *or* rate per the entire focalplane [Hz]
    cosmic_ray_time_constant = "Quantity('1.00000000000000e+00 s')" # Dissipation time of cosmic ray events on the focaplane
    det_data = "signal" # Observation detdata key for simulated signal
    enabled = false # If True, this class instance is marked as enabled
    glitch_amplitude_center = "Quantity('1.00000000000000e+00 K')" # Center of Gaussian distribution for glitch amplitude
    glitch_amplitude_sigma = "Quantity('1.00000000000000e+00 K')" # Width of Gaussian distribution for glitch amplitude
    glitch_rate = "Quantity('1.00000000000000e-01 Hz')" # Glitch occurrence rate
    jump_amplitude_center = "Quantity('0.00000000000000e+00 mK')" # Center of Gaussian distribution for jump amplitude
    jump_amplitude_sigma = "Quantity('1.00000000000000e+00 mK')" # Width of Gaussian distribution for jump amplitude
    jump_rate = "Quantity('1.00000000000000e-03 Hz')" # Jump occurrence rate
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    misidentification_width = "Quantity('1.00000000000000e+00 deg')" # Probability of misidentifying two channels is a Gaussian function of their distance on the focalplane.
    misidentify_bolometers = true # Enable bolometer misidentification
    name = "sim_readout" # The 'name' of this class instance
    realization = 0 # The noise realization index
    shared_flag_mask_readout = 1 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    simulate_glitches = true # Enable glitch simulation
    simulate_jumps = true # Enable jump simulation
    simulate_yield = true # Simulate failed bolometers
    times = "times" # Observation shared key for timestamps
    yield_center = 0.8 # Center of Gaussian distribution for detector yield
    yield_sigma = 0.1 # Width of Gaussian distribution for detector yield

[operators.save_hdf5]
    class = "toast.ops.save_hdf5.SaveHDF5"
    API = 0 # Internal interface version for this operator
    compress_detdata = false # If True, use FLAC to compress detector signal
    compress_precision = "None" # Number of significant digits to retain in detdata compression
    config = "{}" # Write this job config to the file
    detdata = "[]" # Only save this list of detdata objects
    detdata_float32 = false # If True, convert any float64 detector data to float32 on write.
    detdata_in_place = false # If True, all compressed detector data will be decompressed and written over the input data.
    enabled = false # If True, this class instance is marked as enabled
    force_serial = false # Use serial HDF5 operations, even if parallel support available
    intervals = "[]" # Only save this list of intervals objects
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    meta = "[]" # Only save this list of meta objects
    name = "save_hdf5" # The 'name' of this class instance
    shared = "[]" # Only save this list of shared objects
    times = "times" # Observation shared key for timestamps
    verify = false # If True, immediately load data back in and verify
    volume = "toast_out_hdf5" # Top-level directory for the data volume

[operators.noise_cut]
    class = "toast.ops.noise_estimation.NoiseEstim"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame.  Only relevant if `maskfile` and/or `mapfile` are set
    enabled = false # If True, this class instance is marked as enabled
    focalplane_key = "None" # When set, PSDs are measured over averaged TODs
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lagmax = 1024 # Maximum lag to consider for the covariance function. Will be truncated the length of the longest view.
    mapfile = "None" # Optional HEALPix map to sample and subtract from the signal
    mask_flag_mask = 2 # Bit mask for raising processing mask flags
    mask_flags = "flags" # Observation detdata key for processing mask flags
    maskfile = "None" # Optional HEALPix processing mask
    name = "noise_cut" # The 'name' of this class instance
    naverage = 64 # Smoothing kernel width for downsampled data
    nbin_psd = 64 # Bin the resulting PSD
    nocross = true # Do not evaluate cross-PSDs.  Overridden by `pairs`
    nosingle = false # Do not evaluate individual PSDs.  Overridden by `pairs`
    nsum = 1 # Downsampling factor for decimated data
    out_model = "noise_cut" # Create a new noise model with this name
    output_dir = "None" # If specified, write output data products to this directory
    pairs = "[]" # Detector pairs to estimate noise for.  Overrides `nosingle` and `nocross`
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located.  Only relevant if `maskfile` and/or `mapfile` are set
    pixel_pointing = "None" # An instance of a pixel pointing operator.  Only relevant if `maskfile` and/or `mapfile` are set
    pol = true # Sample also the polarized part of the map
    remove_common_mode = true # Remove common mode signal before estimation
    save_cov = false # Save also the sample covariance
    shared_flag_mask = 13 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stationary_period = "Quantity('8.64000000000000e+04 s')" # Break the observation into several estimation periods of this length
    stokes_weights = "None" # An instance of a Stokes weights operator.  Only relevant if `mapfile` is set
    symmetric = false # If True, treat positive and negative lags as equivalent in the cross correlator
    times = "times" # Observation shared key for timestamps
    view = "None" # Only measure the covariance within each view

[operators.noise_cut_fit]
    class = "toast.ops.noise_model.FitNoiseModel"
    API = 0 # Internal interface version for this operator
    bad_fit_mask = 2 # Bit mask to raise for bad fits
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    f_min = "Quantity('1.00000000000000e-05 Hz')" # Low-frequency rolloff of model in the fit
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    least_squares_ftol = 1e-10 # The ftol value passed to the least_squares solver
    least_squares_gtol = "None" # The gtol value passed to the least_squares solver
    least_squares_xtol = "None" # The xtol value passed to the least_squares solver
    name = "noise_cut_fit" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "noise_cut_fit" # Create a new noise model with this name
    white_noise_max = "None" # The maximum frequency to consider for the white noise plateau
    white_noise_min = "None" # The minimum frequency to consider for the white noise plateau

[operators.noise_cut_flag]
    class = "toast.ops.noise_model.FlagNoiseFit"
    API = 0 # Internal interface version for this operator
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "noise_cut_flag" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the noise model
    outlier_flag_mask = 2 # Bit mask to raise flags with
    sigma_NET = 5.0 # Flag detectors with NET values outside this range
    sigma_fknee = 5.0 # Flag detectors with knee frequency values outside this range

[operators.hwpfilter]
    class = "toast.ops.hwpfilter.HWPFilter"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detrend = false # Subtract the fitted trend along with the ground template
    enabled = false # If True, this class instance is marked as enabled
    filter_order = 5 # Order of a Fourier expansion to fit as a function of HWP angle.
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    hwp_flag_mask = 1 # Bit mask to use when adding flags based on HWP filter failures.
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "hwpfilter" # The 'name' of this class instance
    shared_flag_mask = 1 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    trend_order = 5 # Order of a Legendre polynomial to fit along with the HWPSS template.
    view = "None" # Use this view of the data in all observations

[operators.demodulate]
    class = "toast.ops.demodulation.Demodulate"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for Azimuth
    boresight = "boresight_radec" # Observation shared key for boresight
    demod_flag_mask = 1 # Bit mask value for demod & downsample flagging
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    do_2f = false # also cache the 2f-demodulated signal
    elevation = "elevation" # Observation shared key for Elevation
    enabled = false # If True, this class instance is marked as enabled
    fmax = "None" # Override automatic lowpass cut-off frequency
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "demodulate" # The 'name' of this class instance
    noise_model = "noise_model" # Observation key containing the noise model
    nskip = 3 # Downsampling factor
    purge = false # Remove inputs after demodulation
    shared_flag_mask = 1 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    times = "times" # Observation shared key for timestamps
    window = "hamming" # Window function name recognized by scipy.signal.firwin
    wkernel = "None" # Override automatic filter kernel size

[operators.demod_noise_estim]
    class = "toast.ops.noise_estimation.NoiseEstim"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame.  Only relevant if `maskfile` and/or `mapfile` are set
    enabled = false # If True, this class instance is marked as enabled
    focalplane_key = "None" # When set, PSDs are measured over averaged TODs
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lagmax = 1024 # Maximum lag to consider for the covariance function. Will be truncated the length of the longest view.
    mapfile = "None" # Optional HEALPix map to sample and subtract from the signal
    mask_flag_mask = 2 # Bit mask for raising processing mask flags
    mask_flags = "flags" # Observation detdata key for processing mask flags
    maskfile = "None" # Optional HEALPix processing mask
    name = "demod_noise_estim" # The 'name' of this class instance
    naverage = 64 # Smoothing kernel width for downsampled data
    nbin_psd = 64 # Bin the resulting PSD
    nocross = true # Do not evaluate cross-PSDs.  Overridden by `pairs`
    nosingle = false # Do not evaluate individual PSDs.  Overridden by `pairs`
    nsum = 1 # Downsampling factor for decimated data
    out_model = "demod_noise" # Create a new noise model with this name
    output_dir = "None" # If specified, write output data products to this directory
    pairs = "[]" # Detector pairs to estimate noise for.  Overrides `nosingle` and `nocross`
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located.  Only relevant if `maskfile` and/or `mapfile` are set
    pixel_pointing = "None" # An instance of a pixel pointing operator.  Only relevant if `maskfile` and/or `mapfile` are set
    pol = true # Sample also the polarized part of the map
    remove_common_mode = true # Remove common mode signal before estimation
    save_cov = false # Save also the sample covariance
    shared_flag_mask = 13 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stationary_period = "Quantity('8.64000000000000e+04 s')" # Break the observation into several estimation periods of this length
    stokes_weights = "None" # An instance of a Stokes weights operator.  Only relevant if `mapfile` is set
    symmetric = false # If True, treat positive and negative lags as equivalent in the cross correlator
    times = "times" # Observation shared key for timestamps
    view = "None" # Only measure the covariance within each view

[operators.demod_noise_estim_fit]
    class = "toast.ops.noise_model.FitNoiseModel"
    API = 0 # Internal interface version for this operator
    bad_fit_mask = 2 # Bit mask to raise for bad fits
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    f_min = "Quantity('1.00000000000000e-05 Hz')" # Low-frequency rolloff of model in the fit
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    least_squares_ftol = 1e-10 # The ftol value passed to the least_squares solver
    least_squares_gtol = "None" # The gtol value passed to the least_squares solver
    least_squares_xtol = "None" # The xtol value passed to the least_squares solver
    name = "demod_noise_estim_fit" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "demod_noise_fit" # Create a new noise model with this name
    white_noise_max = "None" # The maximum frequency to consider for the white noise plateau
    white_noise_min = "None" # The minimum frequency to consider for the white noise plateau

[operators.noise_estim]
    class = "toast.ops.noise_estimation.NoiseEstim"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame.  Only relevant if `maskfile` and/or `mapfile` are set
    enabled = false # If True, this class instance is marked as enabled
    focalplane_key = "None" # When set, PSDs are measured over averaged TODs
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    lagmax = 1024 # Maximum lag to consider for the covariance function. Will be truncated the length of the longest view.
    mapfile = "None" # Optional HEALPix map to sample and subtract from the signal
    mask_flag_mask = 2 # Bit mask for raising processing mask flags
    mask_flags = "flags" # Observation detdata key for processing mask flags
    maskfile = "None" # Optional HEALPix processing mask
    name = "noise_estim" # The 'name' of this class instance
    naverage = 64 # Smoothing kernel width for downsampled data
    nbin_psd = 64 # Bin the resulting PSD
    nocross = true # Do not evaluate cross-PSDs.  Overridden by `pairs`
    nosingle = false # Do not evaluate individual PSDs.  Overridden by `pairs`
    nsum = 1 # Downsampling factor for decimated data
    out_model = "noise_estim" # Create a new noise model with this name
    output_dir = "None" # If specified, write output data products to this directory
    pairs = "[]" # Detector pairs to estimate noise for.  Overrides `nosingle` and `nocross`
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located.  Only relevant if `maskfile` and/or `mapfile` are set
    pixel_pointing = "None" # An instance of a pixel pointing operator.  Only relevant if `maskfile` and/or `mapfile` are set
    pol = true # Sample also the polarized part of the map
    remove_common_mode = true # Remove common mode signal before estimation
    save_cov = false # Save also the sample covariance
    shared_flag_mask = 13 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stationary_period = "Quantity('8.64000000000000e+04 s')" # Break the observation into several estimation periods of this length
    stokes_weights = "None" # An instance of a Stokes weights operator.  Only relevant if `mapfile` is set
    symmetric = false # If True, treat positive and negative lags as equivalent in the cross correlator
    times = "times" # Observation shared key for timestamps
    view = "None" # Only measure the covariance within each view

[operators.noise_estim_fit]
    class = "toast.ops.noise_model.FitNoiseModel"
    API = 0 # Internal interface version for this operator
    bad_fit_mask = 2 # Bit mask to raise for bad fits
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    f_min = "Quantity('1.00000000000000e-05 Hz')" # Low-frequency rolloff of model in the fit
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    least_squares_ftol = 1e-10 # The ftol value passed to the least_squares solver
    least_squares_gtol = "None" # The gtol value passed to the least_squares solver
    least_squares_xtol = "None" # The xtol value passed to the least_squares solver
    name = "noise_estim_fit" # The 'name' of this class instance
    noise_model = "noise_model" # The observation key containing the input noise model
    out_model = "noise_estim_fit" # Create a new noise model with this name
    white_noise_max = "None" # The maximum frequency to consider for the white noise plateau
    white_noise_min = "None" # The minimum frequency to consider for the white noise plateau

[operators.processing_mask_pixels]
    class = "toast.ops.pixels_healpix.pixels_healpix.PixelsHealpix"
    API = 0 # Internal interface version for this operator
    create_dist = "None" # Create the submap distribution for all detectors and store in the Data key specified
    detector_pointing = "None" # Operator that translates boresight pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "processing_mask_pixels" # The 'name' of this class instance
    nest = true # If True, use NESTED ordering instead of RING
    nside = 64 # The NSIDE resolution
    nside_submap = 16 # The NSIDE of the submap resolution
    pixels = "pixels_processing_mask" # Observation detdata key for output pixel indices
    single_precision = false # If True, use 32bit int in output
    view = "None" # Use this view of the data in all observations

[operators.processing_mask]
    class = "toast.ops.scan_healpix.ScanHealpixMask"
    API = 0 # Internal interface version for this operator
    det_flags = "flags" # Observation detdata key for flags to use
    det_flags_value = 2 # The detector flag value to set where the mask result is non-zero
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    file = "None" # Path to healpix FITS file
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    mask_bits = 255 # The number to bitwise-and with each mask value to form the result
    name = "processing_mask" # The 'name' of this class instance
    pixel_dist = "pixel_dist" # The Data key where the PixelDistribution object is located
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    save_mask = false # If True, do not delete mask during finalize
    save_pointing = false # If True, do not clear detector pointing matrices if we generate the pixel distribution

[operators.flag_sso]
    class = "toast.ops.flag_sso.FlagSSO"
    API = 0 # Internal interface version for this operator
    det_flag_mask = 4 # Bit mask to raise flags with
    det_flags = "flags" # Observation detdata key for flags to use
    detector_pointing = "None" # Operator that translates boresight Az/El pointing into detector frame
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "flag_sso" # The 'name' of this class instance
    sso_names = "[]" # Names of the SSOs, must be recognized by pyEphem
    sso_radii = "[]" # Radii around the sources to flag
    times = "times" # Observation shared key for timestamps
    view = "None" # Use this view of the data in all observations

[operators.h_n]
    class = "sotodlib.toast.ops.h_n.Hn"
    API = 0 # Internal interface version for this operator
    det_flag_mask = 1 # Bit mask value for optional detector flagging
    det_flags = "flags" # Observation detdata key for flags to use
    enabled = false # If True, this class instance is marked as enabled
    hwp_angle = "None" # Observation shared key for HWP angle
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "h_n" # The 'name' of this class instance
    nmax = 4 # Maximum `n` to evaluate.
    nmin = 1 # Minimum `n` to evaluate.
    noise_model = "noise_model" # Observation key containing the noise model
    output_dir = "." # Write output data products to this directory
    pixel_dist = "pixel_dist" # The Data key where the PixelDist object should be stored
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    rcond_threshold = 1e-08 # Minimum value for inverse condition number cut.
    save_pointing = false # If True, do not clear detector pointing matrices after use
    shared_flag_mask = 1 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    sync_type = "alltoallv" # Communication algorithm: 'allreduce' or 'alltoallv'

[operators.cadence_map]
    class = "toast.ops.cadence_map.CadenceMap"
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "cadence_map" # The 'name' of this class instance
    output_dir = "." # Write output data products to this directory
    pixel_dist = "None" # The Data key containing the submap distribution
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator.
    save_pointing = false # If True, do not clear pixel numbers after use
    shared_flag_mask = 13 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps

[operators.crosslinking]
    class = "toast.ops.crosslinking.CrossLinking"
    API = 0 # Internal interface version for this operator
    det_data_units = "Unit('K')" # Output units if creating detector data
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "crosslinking" # The 'name' of this class instance
    output_dir = "." # Write output data products to this directory
    pixel_dist = "pixel_dist" # The Data key where the PixelDist object should be stored
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator.
    save_pointing = false # If True, do not clear pixel numbers after use
    shared_flag_mask = 13 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    sync_type = "alltoallv" # Communication algorithm: 'allreduce' or 'alltoallv'

[operators.raw_statistics]
    class = "toast.ops.statistics.Statistics"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key to analyze
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "raw_statistics" # The 'name' of this class instance
    output_dir = "None" # If specified, write output data products to this directory
    shared_flag_mask = 13 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.deconvolve_time_constant]
    class = "toast.ops.time_constant.TimeConstant"
    API = 0 # Internal interface version for this operator
    deconvolve = true # Deconvolve the time constant instead.
    det_data = "signal" # Observation detdata key apply filtering to
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "deconvolve_time_constant" # The 'name' of this class instance
    realization = 0 # Realization ID, only used if tau_sigma is nonzero
    tau = "None" # Time constant to apply to all detectors.  Overrides `tau_name`
    tau_name = "None" # Key to use to find time constants in the Focalplane.
    tau_sigma = "None" # Randomized fractional error to add to each time constant.

[operators.mlmapmaker]
    class = "sotodlib.toast.ops.mlmapmaker.MLMapmaker"
    API = 0 # Internal interface version for this operator
    Nmat = "None" # The noise matrix to use
    area = "None" # Load the enmap geometry from this file
    boresight = "boresight_azel" # Observation shared key for boresight Az/El
    center_at = "None" # The format is [from=](ra:dec|name),[to=(ra:dec|name)],[up=(ra:dec|name|system)]
    comps = "TQU" # Components (must be 'T', 'QU' or 'TQU')
    deslope = true # If True, each observation will have the mean and slope removed.
    det_data = "signal" # Observation detdata key for the timestream data
    det_flag_mask = 1 # Bit mask value for optional detector flagging
    det_flags = "None" # Observation detdata key for flags to use
    dtype_map = "float64" # Numpy dtype of map products
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    maxerr = 1e-06 # Maximum error in the CG solver
    maxiter = 500 # Maximum number of CG iterations
    name = "mlmapmaker" # The 'name' of this class instance
    nmat_dir = "None" # Where to read/write/cache noise matrices. See nmat_mode. If None, write to {out_dir}/nmats
    nmat_mode = "build" # How to initialize the noise matrix.  'build': Always build from data in obs.  'cache': Use if available in nmat_dir, otherwise build and save.  'load': Load from nmat_dir, error if missing.  'save': Build from obs data and save.
    nmat_type = "NmatDetvecs" # Noise matrix type is either `NmatDetvecs`, `NmatUncorr` or `Nmat`
    noise_model = "noise_model" # Observation key containing the noise model
    out_dir = "." # The output directory
    purge_det_data = false # If True, clear all observation detector data after accumulating
    shared_flag_mask = 1 # Bit mask value for optional shared flagging
    shared_flags = "None" # Observation shared key for telescope flags to use
    site = "so" # Site to use when making maps
    tiled = false # If True, the map will be represented as distributed tiles in memory. For large maps this is faster and more memory efficient, but for small maps it has some overhead due to extra communication.
    times = "times" # Observation shared key for timestamps
    truncate_tod = false # Truncate TOD to an easily factorizable length to ensure efficient FFT.
    verbose = 1 # Set verbosity in MLMapmaker.  If None, use toast loglevel
    view = "None" # Use this view of the data in all observations
    weather = "vacuum" # Weather to assume when making maps
    write_bin = true # Write out the binned map
    write_div = true # Write out the noise weight map
    write_hits = true # Write out the hitcount map
    write_iter_map = 10 # Number of iterations between saved maps.  Set to zero to disable.
    write_rhs = true # Write out the right hand side of the mapmaking equation

[operators.groundfilter]
    class = "toast.ops.groundfilter.GroundFilter"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for Azimuth
    boresight_azel = "boresight_azel" # Observation shared key for boresight Az/El
    det_data = "signal" # Observation detdata key
    det_flag_mask = 1 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    detrend = false # Subtract the fitted trend along with the ground template
    enabled = false # If True, this class instance is marked as enabled
    filter_order = 5 # Order of a Legendre polynomial to fit as a function of azimuth.
    ground_flag_mask = 1 # Bit mask to use when adding flags based on ground filter failures.
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    leftright_mask = 8 # Bit mask value for left-to-right scans
    name = "groundfilter" # The 'name' of this class instance
    rightleft_mask = 16 # Bit mask value for right-to-left scans
    shared_flag_mask = 1 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    split_template = false # Apply a different template for left and right scans
    trend_order = 5 # Order of a Legendre polynomial to fit along with the ground template.
    view = "None" # Use this view of the data in all observations

[operators.polyfilter1D]
    class = "toast.ops.polyfilter.polyfilter.PolyFilter"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 3 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 3 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "polyfilter1D" # The 'name' of this class instance
    order = 1 # Polynomial order
    pattern = ".*" # Regex pattern to match against detector names. Only detectors that match the pattern are filtered.
    poly_flag_mask = 1 # Shared flag bit mask for samples outside of filtering view
    shared_flag_mask = 3 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "throw" # Use this view of the data in all observations

[operators.polyfilter2D]
    class = "toast.ops.polyfilter.polyfilter.PolyFilter2D"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 3 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 3 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    focalplane_key = "None" # Which focalplane key to match
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "polyfilter2D" # The 'name' of this class instance
    order = 1 # Polynomial order
    pattern = ".*" # Regex pattern to match against detector names. Only detectors that match the pattern are filtered.
    poly_flag_mask = 1 # Bit mask value for samples that fail to filter
    shared_flag_mask = 1 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps
    view = "None" # Use this view of the data in all observations

[operators.common_mode_filter]
    class = "toast.ops.polyfilter.polyfilter.CommonModeFilter"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key apply filtering to
    det_flag_mask = 3 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 3 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    focalplane_key = "None" # Which focalplane key to match
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "common_mode_filter" # The 'name' of this class instance
    pattern = ".*" # Regex pattern to match against detector names. Only detectors that match the pattern are filtered.
    redistribute = false # If True, redistribute data before and after filtering for optimal data locality.
    shared_flag_mask = 1 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    times = "times" # Observation shared key for timestamps

[operators.binner]
    class = "toast.ops.mapmaker_binning.BinMap"
    API = 0 # Internal interface version for this operator
    binned = "binned" # The Data key where the binned map should be stored
    covariance = "covariance" # The Data key containing the noise covariance PixelData instance
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired timestream units
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = true # If True, this class instance is marked as enabled
    full_pointing = false # If True, expand pointing for all detectors and save
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "binner" # The 'name' of this class instance
    noise_model = "noise_model" # Observation key containing the noise model
    noiseweighted = "None" # The Data key where the noiseweighted map should be stored
    pixel_dist = "pix_dist" # The Data key where the PixelDist object should be stored
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    pre_process = "None" # Optional extra operator to run prior to binning
    shared_flag_mask = 13 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    sync_type = "alltoallv" # Communication algorithm: 'allreduce' or 'alltoallv'

[operators.binner_final]
    class = "toast.ops.mapmaker_binning.BinMap"
    API = 0 # Internal interface version for this operator
    binned = "binned" # The Data key where the binned map should be stored
    covariance = "covariance" # The Data key containing the noise covariance PixelData instance
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired timestream units
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    full_pointing = false # If True, expand pointing for all detectors and save
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "binner_final" # The 'name' of this class instance
    noise_model = "noise_model" # Observation key containing the noise model
    noiseweighted = "None" # The Data key where the noiseweighted map should be stored
    pixel_dist = "pix_dist_final" # The Data key where the PixelDist object should be stored
    pixel_pointing = "None" # This must be an instance of a pixel pointing operator
    pre_process = "None" # Optional extra operator to run prior to binning
    shared_flag_mask = 13 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    stokes_weights = "None" # This must be an instance of a Stokes weights operator
    sync_type = "alltoallv" # Communication algorithm: 'allreduce' or 'alltoallv'

[operators.mapmaker]
    class = "toast.ops.mapmaker.MapMaker"
    API = 0 # Internal interface version for this operator
    binning = "None" # Binning operator used for solving template amplitudes
    convergence = 1e-12 # Relative convergence limit
    det_data = "signal" # Observation detdata key for the timestream data
    enabled = true # If True, this class instance is marked as enabled
    iter_max = 100 # Maximum number of iterations
    iter_min = 3 # Minimum number of iterations
    keep_final_products = false # If True, keep the map domain products in data after write
    keep_solver_products = false # If True, keep the map domain solver products in data
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    map_binning = "None" # Binning operator for final map making.  Default is same as solver
    map_rcond_threshold = 1e-08 # For final map, minimum value for inverse pixel condition number cut.
    mask = "None" # Data key for pixel mask to use in solving.  First bit of pixel values is tested
    mc_index = "None" # The Monte-Carlo index
    mc_mode = false # If True, re-use solver flags, sparse covariances, etc
    name = "mapmaker" # The 'name' of this class instance
    output_dir = "." # Write output data products to this directory
    overwrite_cleaned = false # If True and save_cleaned is True, overwrite the input data
    report_memory = false # Report memory throughout the execution
    reset_pix_dist = false # Clear any existing pixel distribution.  Useful when applying repeatedly to different data objects.
    save_cleaned = false # If True, save the template-subtracted detector timestreams
    solve_rcond_threshold = 1e-08 # When solving, minimum value for inverse pixel condition number cut.
    template_matrix = "None" # This must be an instance of a template matrix operator
    write_binmap = true # If True, write the projected map *before* template subtraction
    write_cov = true # If True, write the white noise covariance matrices.
    write_hdf5 = false # If True, outputs are in HDF5 rather than FITS format.
    write_hdf5_serial = false # If True, force serial HDF5 write of output maps.
    write_hits = true # If True, write the hits map
    write_invcov = false # If True, write the inverse white noise covariance matrices.
    write_map = true # If True, write the projected map
    write_noiseweighted_map = false # If True, write the noise-weighted map
    write_rcond = true # If True, write the reciprocal condition numbers.
    write_solver_products = false # If True, write out equivalent solver products.

[operators.filterbin]
    class = "toast.ops.filterbin.FilterBin"
    API = 0 # Internal interface version for this operator
    azimuth = "azimuth" # Observation shared key for Azimuth
    binning = "None" # Binning operator for map making.
    cache_dir = "None" # Cache directory for additive observation matrix products
    deproject_map = "None" # Healpix map containing the deprojection templates: intensity map and its derivatives
    deproject_nnz = 1 # Number of deprojection templates to regress.  Must be less than or equal to number of columns in `deproject_map`.
    deproject_pattern = ".*" # Regular expression to test detector names with.  Only matching detectors will be deprojected.  Used to identify differenced TOD.
    det_data = "signal" # Observation detdata key for the timestream data
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    filter_flag_mask = 1 # Bit mask value for flagging samples that fail filtering
    ground_filter_order = 5 # Order of a Legendre polynomial to fit as a function of azimuth.
    hwp_angle = "hwp_angle" # Observation shared key for HWP angle
    hwp_filter_order = "None" # Order of HWP-synchronous signal filter.
    keep_final_products = false # If True, keep the map domain products in data after write
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    leftright_mask = 8 # Bit mask value for left-to-right scans
    maskfile = "None" # Optional processing mask
    mc_index = "None" # The Monte-Carlo index
    mc_mode = false # If True, re-use solver flags, sparse covariances, etc
    name = "filterbin" # The 'name' of this class instance
    noiseweight_obs_matrix = false # If True, observation matrix should match noise-weighted maps
    output_dir = "." # Write output data products to this directory
    poly_filter_order = 1 # Polynomial order
    poly_filter_view = "throw" # Intervals for polynomial filtering
    rcond_threshold = 0.001 # Minimum value for inverse pixel condition number cut.
    report_memory = false # Report memory throughout the execution
    reset_pix_dist = false # Clear any existing pixel distribution.  Useful when applyingrepeatedly to different data objects.
    rightleft_mask = 16 # Bit mask value for right-to-left scans
    shared_flag_mask = 13 # Bit mask value for optional telescope flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    split_ground_template = false # Apply a different template for left and right scans
    write_binmap = false # If True, write the unfiltered map
    write_cov = true # If True, write the white noise covariance matrices.
    write_hdf5 = false # If True, output maps are in HDF5 rather than FITS format.
    write_hdf5_serial = false # If True, force serial HDF5 write of output maps.
    write_hits = true # If True, write the hits map
    write_invcov = false # If True, write the inverse white noise covariance matrices.
    write_map = true # If True, write the filtered map
    write_noiseweighted_binmap = false # If True, write the noise-weighted unfiltered map
    write_noiseweighted_map = false # If True, write the noise-weighted filtered map
    write_obs_matrix = false # Write the observation matrix
    write_rcond = true # If True, write the reciprocal condition numbers.

[operators.filtered_statistics]
    class = "toast.ops.statistics.Statistics"
    API = 0 # Internal interface version for this operator
    det_data = "signal" # Observation detdata key to analyze
    det_flag_mask = 7 # Bit mask value for detector sample flagging
    det_flags = "flags" # Observation detdata key for flags to use
    det_mask = 7 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "filtered_statistics" # The 'name' of this class instance
    output_dir = "None" # If specified, write output data products to this directory
    shared_flag_mask = 13 # Bit mask value for optional shared flagging
    shared_flags = "flags" # Observation shared key for telescope flags to use
    view = "None" # Use this view of the data in all observations

[operators.mem_count]
    class = "toast.ops.memory_counter.MemoryCounter"
    API = 0 # Internal interface version for this operator
    enabled = false # If True, this class instance is marked as enabled
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "mem_count" # The 'name' of this class instance
    prefix = "''" # Prefix for log messages
    silent = false # If True, return the memory used but do not log the result

[templates]
[templates.baselines]
    class = "toast.templates.offset.offset.Offset"
    data = "None" # This must be an instance of a Data class (or None)
    debug_plots = "None" # If not None, make debugging plots in this directory
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired units of detector data
    det_flag_mask = 1 # Bit mask value for solver flags
    det_flags = "flags" # Observation detdata key for solver flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    good_fraction = 0.5 # Fraction of unflagged samples needed to keep a given offset amplitude
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    name = "baselines" # The 'name' of this class instance
    noise_model = "None" # Observation key containing the optional noise model
    precond_width = 20 # Preconditioner width in terms of offsets / baselines
    step_time = "Quantity('2.00000000000000e+00 s')" # Time per baseline step
    times = "times" # Observation shared key for timestamps
    use_noise_prior = false # Use detector PSDs to build the noise prior and preconditioner
    view = "None" # Use this view of the data in all observations

[templates.azss]
    class = "toast.templates.periodic.Periodic"
    bins = "None" # Number of bins between min / max values of data key
    data = "None" # This must be an instance of a Data class (or None)
    det_data = "signal" # Observation detdata key for the timestream data
    det_data_units = "Unit('K')" # Desired units of detector data
    det_flag_mask = 1 # Bit mask value for solver flags
    det_flags = "flags" # Observation detdata key for solver flags to use
    det_mask = 1 # Bit mask value for per-detector flagging
    enabled = false # If True, this class instance is marked as enabled
    flag_mask = 1 # Bit mask value for flags
    flags = "flags" # Observation data key for flags to use
    increment = 0.0174532925199433 # The increment of the data key for each bin
    is_detdata_key = false # If True, the periodic data and flags are detector fields, not shared
    kernel_implementation = 0 # Which kernel implementation to use (DEFAULT, COMPILED, NUMPY, JAX).
    key = "azimuth" # Observation data key for the periodic quantity
    minimum_bin_hits = 3 # Minimum number of samples per amplitude bin
    name = "azss" # The 'name' of this class instance
    view = "None" # Use this view of the data in all observations
